{"version":3,"file":"assemble_test_cases.js","sourceRoot":"","sources":["../../src/assemble/assemble_test_cases.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter } from 'node:events'\nimport {\n  Envelope,\n  IdGenerator,\n  Pickle,\n  TestCase,\n  TestStep,\n  Group as MessagesGroup,\n} from '@cucumber/messages'\nimport { Group } from '@cucumber/cucumber-expressions'\nimport { SupportCodeLibrary } from '../support_code_library_builder/types'\nimport { doesHaveValue } from '../value_checker'\nimport { AssembledTestCase, SourcedPickle } from './types'\n\nexport async function assembleTestCases({\n  eventBroadcaster,\n  newId,\n  sourcedPickles,\n  supportCodeLibrary,\n}: {\n  eventBroadcaster: EventEmitter\n  newId: IdGenerator.NewId\n  sourcedPickles: ReadonlyArray<SourcedPickle>\n  supportCodeLibrary: SupportCodeLibrary\n}): Promise<ReadonlyArray<AssembledTestCase>> {\n  return sourcedPickles.map(({ gherkinDocument, pickle }) => {\n    const testCaseId = newId()\n    const fromBeforeHooks: TestStep[] = makeBeforeHookSteps({\n      supportCodeLibrary,\n      pickle,\n      newId,\n    })\n    const fromStepDefinitions: TestStep[] = makeSteps({\n      pickle,\n      supportCodeLibrary,\n      newId,\n    })\n    const fromAfterHooks: TestStep[] = makeAfterHookSteps({\n      supportCodeLibrary,\n      pickle,\n      newId,\n    })\n    const testCase: TestCase = {\n      pickleId: pickle.id,\n      id: testCaseId,\n      testSteps: [\n        ...fromBeforeHooks,\n        ...fromStepDefinitions,\n        ...fromAfterHooks,\n      ],\n    }\n    eventBroadcaster.emit('envelope', { testCase } satisfies Envelope)\n    return {\n      gherkinDocument,\n      pickle,\n      testCase,\n    }\n  })\n}\n\nfunction makeAfterHookSteps({\n  supportCodeLibrary,\n  pickle,\n  newId,\n}: {\n  supportCodeLibrary: SupportCodeLibrary\n  pickle: Pickle\n  newId: IdGenerator.NewId\n}): TestStep[] {\n  return supportCodeLibrary.afterTestCaseHookDefinitions\n    .slice(0)\n    .reverse()\n    .filter((hookDefinition) => hookDefinition.appliesToTestCase(pickle))\n    .map((hookDefinition) => ({\n      id: newId(),\n      hookId: hookDefinition.id,\n    }))\n}\n\nfunction makeBeforeHookSteps({\n  supportCodeLibrary,\n  pickle,\n  newId,\n}: {\n  supportCodeLibrary: SupportCodeLibrary\n  pickle: Pickle\n  newId: IdGenerator.NewId\n}): TestStep[] {\n  return supportCodeLibrary.beforeTestCaseHookDefinitions\n    .filter((hookDefinition) => hookDefinition.appliesToTestCase(pickle))\n    .map((hookDefinition) => ({\n      id: newId(),\n      hookId: hookDefinition.id,\n    }))\n}\n\nfunction makeSteps({\n  pickle,\n  supportCodeLibrary,\n  newId,\n}: {\n  pickle: Pickle\n  supportCodeLibrary: SupportCodeLibrary\n  newId: () => string\n}): TestStep[] {\n  return pickle.steps.map((pickleStep) => {\n    const stepDefinitions = supportCodeLibrary.stepDefinitions.filter(\n      (stepDefinition) => stepDefinition.matchesStepName(pickleStep.text)\n    )\n    return {\n      id: newId(),\n      pickleStepId: pickleStep.id,\n      stepDefinitionIds: stepDefinitions.map(\n        (stepDefinition) => stepDefinition.id\n      ),\n      stepMatchArgumentsLists: stepDefinitions.map((stepDefinition) => {\n        const result = stepDefinition.expression.match(pickleStep.text)\n        return {\n          stepMatchArguments: result.map((arg) => {\n            return {\n              group: mapArgumentGroup(arg.group),\n              parameterTypeName: arg.parameterType.name,\n            }\n          }),\n        }\n      }),\n    }\n  })\n}\n\nfunction mapArgumentGroup(group: Group): MessagesGroup {\n  return {\n    start: group.start,\n    value: group.value,\n    children: doesHaveValue(group.children)\n      ? group.children.map((child) => mapArgumentGroup(child))\n      : undefined,\n  }\n}\n"]}